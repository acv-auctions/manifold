.. currentmodule:: manifold.file

Thrift <==> Python Conversion
=============================

If you are using Python as a Thrift server, then it would be very helpful to easily convert between Thrift structs and
types versus Python instances and types. Manifold allows you to do this with ease.

Loading Thrift Modules in Python
********************************

Manifold uses `Thriftpy <https://github.com/eleme/thriftpy>`__ to in-memory generate a Python module from the defined
Thrift files. Note that these are only loaded when called and are cached, to save memory and performance.

Manifold will automatically convert Thrift types and structs to and from their Python types / instances on incoming
requests and outgoing responses.

``load_module`` Function
------------------------

To use Thrift-defined structures and types in Python, import the Thrift file as a Python module using ``load_module``,
which is described below:

.. autofunction:: load_module

The ``key`` parameter is used to specify which ``MANIFOLD`` configuration to load from. Since you can define multiple
Thrift files / services, the key allows you to load a specific one.


Basic Types
-----------

Basic Thrift types and containers are generated by Manifold into equivalent Python types.

* ``i16``/``i32``/``i64``: Becomes a ``int``
* ``string``: Becomes a ``str``
* ``bool``: Becomes a ``bool``
* ``byte``: Becomes a ``int`` in range **[0-256)**
* ``double``: Becomes a ``float``
* ``binary``: Becomes a ``str`` (in testing)
* ``list<t1>``: Becomes a ``list``
* ``set<t1>``: Becomes a ``list``
* ``map<t1,t2>``: Becomes a ``dict``

Be careful with ``list``, ``set``, and ``map``. Since Python *is not* type-checked, the developer will have to
ensure that the types of each item in these containers are correct. Use Validators if needed.

Structs && Exceptions
---------------------

For Thrift structs and Exceptions, they are represented by Python classes. They attributes map directly to Python
instance attributes. Exceptions can also be :code:`raise` -ed. These are defined in the module returned by
``load_module`` described above, so you can call their constructors through ``load_module().<desired struct>(**kwargs)``.
See below for an example.


Example
-------

For an example, let's take the Thrift struct defined in a file below.

::

   struct Task {
       1: i32 user_id,
       2: string status,
       3: bool async = false
   }


Let's also say we have that Thrift file defined in our settings as such:

.. code-block:: python

   MANIFOLD = {
       'task-service': {
           'file': os.path.join(BASE_DIR, 'tasks.thrift'),
           'service': 'TaskService'
       }
   }

We can then load that Thrift in our code to build ``Task`` instances in the following way.

.. code-block:: python
   :linenos:

   from manifold.file import load_module

   # Load the Thrift module
   thrift_module = load_module(key='task-service')

   # Create a Task instance, using kwargs
   task = thrift_module.Task(user_id=123, status='in-progress')

   # Assert our values
   assert task.user_id == 123
   assert task.status == 'in-progress'
   assert task.async == False  # If not given, defaults to None or default value
